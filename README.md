# Л/Р № 2

Цель: изучить настройку CI/CD в GitLab, получить практические навыки по развертыванию раннера и подключению его к репозиторию.

Задание:

Cоздать две ВМ (1 ядро, 2 Гб памяти на каждой будет достаточно). Настроить их в соответствии с заданием 1 из ЛР1. ВМ1 выполняет роль пограничного маршрутизатора, ВМ2 - является машиной в серой локальной сети.
На машине ВМ1 (пограничный маршрутизатор из ЛР1) открыть средствами сетевого экрана порт 22 для доступа только с ВМ2 и 80 для доступа из открытой сети.

На ВМ2 поднять shell-раннер и подключить его к репозиторию с проектом на кафедральном GitLab.
В качестве проекта можно использовать проект из курса “Основы разработки Web-приложений”, любой другой проект веб-приложения или предлагаемый в задании вариант с Nginx, раздающим статику.

В репозитории настроить CI/CD, состоящий из следующих стадий:
- build (сборка проекта)
- test (запуск тестов)
- deploy (развертывание собранного приложения на ВМ1)

Стадии build и test должны быть автоматическими, доступными для любой ветки. Стадия deploy – мануальной, доступной только для веток main/master и develop.

В результате прохождения пайплайна приложение должно быть доступно на ВМ1 на порту 80.

Для выполнения CI/CD пайплайна запрещено использовать пользователя root на ВМ1 и ВМ2!

При выборе проекта со статикой и веб-сервером Nginx в пайплайне требуется реализовать следующую логику:
1. На стадии build динамически формируются файлы со статикой. Обязательно при генерации статики использовать данные из коммита (например, хэш коммита или лежащий файлик в репозитории с какими-то данными и т.д.). В качестве статики предлагается генерация картинки/QR-кода любыми средствами (скрипты, утилиты) и вставка ее в html-страницу. Html-страница должна также содержать некоторый генерируемый на этапе билда из данных коммита текст (например, можно брать этот текст из файла в репозитории, который меняется через коммиты). На выходе формируется статика, состоящая из html-страницы и изображения на ней. Пример инструмента для генерации картинки: https://fixmypc.ru/post/vstavka-teksta-i-izobrazheniia-v-kartinku-s-python-pillow-pil/
2. На стадии тестов необходимо сделать проверку синтаксиса конфига Nginx соответствующими командами. Проверка делается на машине, где будет использоваться конфиг. Конфигурация веб-сервера должна храниться в gitlab-репозитории. Изменения конфигурации веб-сервера происходят через commit в gitlab.
3. На стадии деплоя разворачивается проект на ВМ1 и происходит актуализация конфига веб-сервера (Nginx). После деплоя на ВМ1 должны быть актуальный статический контент и веб-сервер, работающий с актуальным конфигом.

# Решения

## Подключаем раннер
1. Заходим на иушний гит лаб
* Создаем новый репо
* Переходим в репо
* Переходим в Settings -> CI/CD
* Открываем вкладку *Runners*, затем инструкцию по установке *Show runner installation instructions* (в последнем пункте есть $REGISTRATION_TOKEN. Его тоже берем из гит лаба рядом с инструкцией). Держим открытой, потом будем ее выполнять на ВМ2.


1. Заходим на ВМ1 
* Устанвливаем ssh `sudo apt update` и `sudo apt install openssh-server`
* Смотрим что все ок `sudo systemctl status ssh`
<!-- * Устанавливаем докер `sudo apt install docker.io docker-compose`
* Добавляем вашего юзера группу docker  -->

2. Заходим на ВМ2 (Можно подключиться по ssh к ВМ2 (как по заданию в первой л/р), чтобы было удобнее работать через консоль хостовой машины
* Создаем юзера gitlab-runner `sudo useradd gitlab-runner -d /home/gitlab-runner -m -G users -s /bin/bash` и добавляем его в группу sudo `sudo usermod -a -G sudo gitlab-runner`
* Ставим пароль `sudo passwd gitlab-runner`
* Заходим под gitlab-runner
* Генерируем ssh ключи `sudo ssh-keygen`
* Копируем публичный ключ на ВМ1 `sudo ssh-copy-id <юзер на ВМ1>@<ip-ВМ1>`
* Пробуем подключиться к ВМ1 `sudo ssh <юзер на ВМ1>@<ip-ВМ1>` (пароль запрашиваться не должен)
* Выполняем про сказанную ранее инструкцию на ВМ2, но регистрацию выполняем не под *sudo* и `sudo gitlab-runner start` пока не выполняем.
* Во время регистрации раннера на этапе выбора тега пишем *default*, на этапе с выбором экзекьютора выбираем *shell*.
* После регистрации раннера добавляем в */home/gitlab-runner/.gitlab-runner/config.toml* в блоке *[[runners]]* добавляем строчку `log_level = "debug"`.
* Делаем `sudo gitlab-runner start` и `gitlab-runner run`

## Тестим раннер
1. Заходим в репо
* Заходим в Setting -> CI/CD, открываем Runners и там должен появиться наш раннер.
* Пихаем в master файл *gitlab-ci.yml*, который приложен в репо
* Пушим в ветку, смотрим что раннер взял в работу пайп и смотрим что все ок (особенно чекните, что успешно прошло соединение по ssh - в данном пайпе должно вывести список интерфейсов ВМ1)

## Как деплоить
Тут хз чем вам сказать. Я сам ппо проект поднимал через докер, но это запарно
1. Вариант как в задании сказано.
* Ну тут делать все как в условии. Единственное, может возникнуть проблема с тестами и деплоем. С тестами не понял, почему на ВМ1, если тесты должны запускаться на раннере (ВМ2), но ладно. В любом случае должен быть nginx и там прям отдельная команда есть для проверки. Для деплоя копируете при помощи ssh (который уже настроили) и утилиты scp  в нужную директорию для nginx. Ток трабл, что это под sudo надо делать (уже внутри ВМ1 после подключения по ssh), но там вроде можно как-то без парольный доступ к команде sudo сделать для юзера.

* (вообще лучше на раннере делать тесты, потому что это блин ТЕСТЫ, которые должны эмулировать контур, на котором деплой делается. Поэтому ставите на раннер (ВМ2) nginx и так уже выполняете нужную команду для чека. Хотя тут опять трабл с sudo, тк с nginx работа только через sudo)

2. Варик с докером. Но предыдущий варик полегче будет (зато без траблов с sudo)
* Можете написать обычный сервер с api, который по ручке возвращает json с разным содержимым (который можно менять, что требуется по условию лабы). Пихаете это в Dockerfile. Делаете билд и пуш в докер хаб. Потом по ssh делаете деплой с docker run и нужной ссылкой на ваш образ. Свой варик gitlab-ci по работе с докер (правда там еще и docker-compose есть) прилагаю.



<!-- 
Заходим на ВМ2.
Запускаем `sudo apt update` и устанавливаем docker `sudo apt install docker.io git curl build-essential`.
Добавляем юзера в группу `sudo usermod -aG docker gitlab-runner`.
Проверяем что все ок `groups gitlab-runner`.


`groups` смотрим что юзер добавился в группу
Создаем папку `mkdir gitlab-runner` и в ней *docker-compose* `touch docker-compose.yml`
Тут же создаем папки *data* и *config* `sudo mkdir data config`
В него пихаем содержимое docker-compose.yml из ветки.
Создаем *.env* и пихаем туда:
```
REGISTRATION_TOKEN=
CI_SERVER_URL=https://git.iu7.bmstu.ru
RUNNER_NAME=main
``` 

клюя для токена берем из гитлаба

делаем docker-compose up dind
docker-compose up runner
docker-compose up register -->